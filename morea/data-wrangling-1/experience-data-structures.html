<!DOCTYPE html>
<html lang="en">
<head>
  <title> Change-HI/EDU | 3. Loading and Handling Pandas Data </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8">

  <link rel="stylesheet" href="/css/themes/spacelab/bootstrap.min.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <script src="https://kit.fontawesome.com/020726ec0d.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js"></script>

  

  <!-- Load JQuery, then use it to attach the class 'active' to navbar item currently displayed. -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script>
    $(window).on('load', function () {
      $('.nav-item').find('a[href="' + location.pathname + '"]').addClass('active');
    });
  </script>

</head>
<body>

<div class="navbar navbar-expand-lg fixed-top navbar-light bg-light">
  <div class="container">
    <a class="navbar-brand" href="/index.html"> Change-HI/EDU </a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav">
        
        <li class="nav-item"><a class="nav-link" href="/modules/">Modules</a></li>
        
        <li class="nav-item"><a class="nav-link" href="/outcomes/">Outcomes</a></li>
        
        
        <li class="nav-item"><a class="nav-link" href="/readings/">Readings</a></li>
        
        
        <li class="nav-item"><a class="nav-link" href="/experiences/">Experiences</a></li>
        
        
        <li class="nav-item"><a class="nav-link" href="/assessments/">Assessments</a></li>
        
        
      </ul>
    </div>
  </div>
</div>

<!-- Internal fragment for displaying the breadcrumb bar -->
<div class="breadcrumb-background" style="padding-top: 1em; padding-bottom: .01em">
  <div class="container">
    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
        
        <li class="breadcrumb-item"><a href="/">Home</a></li>
        <li class="breadcrumb-item"><a href="/modules">Modules</a></li>
        <li class="breadcrumb-item"><a href="/modules/"></a></li>
        <li class="breadcrumb-item active">3. Loading and Handling Pandas Data</li>
      </ol>
    </nav>
  </div>
</div>


<div class="container">
  <h1 id="3-loading-and-handling-pandas-data">3. Loading and Handling Pandas Data</h1>

<div class="alert alert-success mt-3" role="alert">
  <p><i class="fa-solid fa-globe fa-xl"></i> <strong>Overview</strong></p>
  <hr />

  <p><strong>Questions</strong></p>
  <ul>
    <li>How are Pandas data structures setup?</li>
    <li>How to load data into Pandas?</li>
    <li>How to write data from Pandas to a file.</li>
  </ul>

  <p><strong>Objectives</strong></p>
  <ul>
    <li>Understand the usefulness of Pandas when loading data.</li>
    <li>Understand how to load data and deal with common issues.</li>
  </ul>
</div>

<p><a href="https://mybinder.org/v2/gh/CI-TRACS/Data_Wrangling_with_Computational_Notebooks/HEAD"><img src="https://mybinder.org/badge_logo.svg" alt="Binder" /></a></p>

<h2 id="pandas-data-structures">Pandas Data Structures</h2>

<p>For this episode you should follow along inside the Jupyter notebook associated with this episode. The jupyter notebooks for this entire lesson can be found in Binder (<a href="https://mybinder.org/v2/gh/CI-TRACS/Data_Wrangling_with_Computational_Notebooks/HEAD">Link to lesson’s Binder website</a>). You will have to navigate to the “notebook” directory in the file browser to find the notebook associated with this episode.</p>

<p>Before we start loading data into Pandas we need to become familiar with 2 of the primary data structures of Pandas:</p>

<ul>
  <li>Series</li>
  <li>DataFrames</li>
</ul>

<p>The reason we use <code class="language-plaintext highlighter-rouge">Series</code> and <code class="language-plaintext highlighter-rouge">DataFrames</code> rather than native python data structures to hold our data is because there are additional attributes and methods associated with <code class="language-plaintext highlighter-rouge">Series</code> and <code class="language-plaintext highlighter-rouge">DataFrames</code> that will be useful for wrangling and analytics. One of the primary benefits of <code class="language-plaintext highlighter-rouge">Series</code> and <code class="language-plaintext highlighter-rouge">DataFrames</code> over native python data structures is that it is a very natural way to describe a data set in an excel-like manner by referencing the rows and columns of our data with labels of our choosing.</p>

<h2 id="pandas-series-vs-dataframes">Pandas <code class="language-plaintext highlighter-rouge">Series</code> Vs. <code class="language-plaintext highlighter-rouge">DataFrames</code></h2>

<p>Pandas has two principal data structures, <code class="language-plaintext highlighter-rouge">Series</code> and <code class="language-plaintext highlighter-rouge">DataFrames</code>. If you are familiar with Microsoft’s Excel application then you can liken <code class="language-plaintext highlighter-rouge">Series</code> to single columns (or rows) in an Excel sheet and <code class="language-plaintext highlighter-rouge">DataFrames</code> to entire tables (or spreadsheets).</p>

<figure>
  
    <img src="/morea/data-wrangling/fig/E3_1_series_vs_dataframe.png" style="max-width: 60%;" alt="/Series%20vs%20DataFrames" class="img-fluid mx-auto d-block border" />
  
  <figcaption style="text-align: center">
    <small>
      
    </small>
  </figcaption>
</figure>

<p>We see in the image above that a <code class="language-plaintext highlighter-rouge">Series</code> in the context of Excel could be the first row of the spreadsheet, while a <code class="language-plaintext highlighter-rouge">DataFrames</code> would be the entire spreadsheet. In other words, a <code class="language-plaintext highlighter-rouge">DataFrames</code> is simply a collection of labeled <code class="language-plaintext highlighter-rouge">Series</code>.</p>

<h2 id="pandas-data-types">Pandas Data Types</h2>

<p>When creating a <code class="language-plaintext highlighter-rouge">Series</code> Pandas will store all the data as the same type. The mapping from the native python types to what they would be in Pandas is summarized below.</p>

<table class="table">
  <thead>
    <tr>
      <th style="text-align: left">Python Type</th>
      <th style="text-align: left">Equivalent Pandas Type</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">string or mixed</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">object</code></td>
      <td style="text-align: left">Columns contain partially or completely made up from strings</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">int</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">int64</code></td>
      <td style="text-align: left">Columns with numeric (integer) values. The 64 here refers <br />to size of the memory space allocated to this type</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">float</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">float64</code></td>
      <td style="text-align: left">Columns with floating points numbers (numbers with decimal points)</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td style="text-align: left">True/False values</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">datetime</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">datetime</code></td>
      <td style="text-align: left">Date and/or time values</td>
    </tr>
  </tbody>
</table>

<h2 id="pandas-dataframes-basics">Pandas <code class="language-plaintext highlighter-rouge">DataFrames</code> Basics</h2>

<p><code class="language-plaintext highlighter-rouge">DataFrames</code> are essentially ordered collections of <code class="language-plaintext highlighter-rouge">Series</code> with two associated <code class="language-plaintext highlighter-rouge">Index</code> objects, one to label rows and another to label columns. Reiterating the example mentioned earlier, it helps to think of <code class="language-plaintext highlighter-rouge">DataFrames</code> as MS. Excel spreadsheets where each row (or column) as an individual <code class="language-plaintext highlighter-rouge">Series</code>.</p>

<p>You can create <code class="language-plaintext highlighter-rouge">DataFrames</code> from either loading in a file e.g. a csv file or by converting it from a native Python data structure. However, here we will be focusing on loading data from a file and turning it into a <code class="language-plaintext highlighter-rouge">DataFrame</code>.</p>

<h2 id="import-the-pandas-package">Import the Pandas Package</h2>

<p>Before we can load in data from a file we need to load the pandas package. Pandas is often imported with the shortcut, or alias, <code class="language-plaintext highlighter-rouge">pd</code> to reduce the amount of characters needed to use the different methods within it.</p>

<div class="alert alert-secondary" role="alert">

  <h6 id="python">Python</h6>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
</code></pre></div>  </div>

</div>

<h3 id="loading-and-parsing-data">Loading and Parsing Data</h3>

<p>Pandas can load in data from a variety of file formats. However, in most cases you will be loading in data from a plain text file since this is one of the most common and simple ways to store data. Plain text files only contain text without any special formatting or code e.g. <code class="language-plaintext highlighter-rouge">.txt</code>, <code class="language-plaintext highlighter-rouge">.csv</code>, or <code class="language-plaintext highlighter-rouge">.tsv</code> files.</p>

<p>To store data in a plain text file you need a standard way of distinguishing the individual data entries. For example, suppose a file contained the following text:</p>

<div class="alert alert-secondary" role="alert">

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">,</span><span class="n">column1</span><span class="p">,</span><span class="n">column2</span><span class="p">,</span><span class="n">column3</span><span class="p">,</span>
<span class="n">row1</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span>
<span class="n">row2</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span>
<span class="n">row3</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">i</span>
</code></pre></div>  </div>

</div>

<p>A human would see the text above and may be able to discern the 3 columns and 3 rows and the individual data entries and see that the file contains a table that looks like the one below.</p>

<div class="alert alert-secondary" role="alert">

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|      | column 1 | column 2 | column 3 |
| ---- | -------- | -------- | -------- |
| row1 | a        | b        | c        |
| row2 | d        | e        | f        |
| row3 | g        | h        | i        |
</code></pre></div>  </div>

</div>

<p>However, a computer would have no idea how to parse this without any direction; to a computer the text above is just one string of characters. To help the computer parse the text, we could tell it that each data entry is separated by a column and each row is separate by a new line. This way of organizing data is called a plain text file format.</p>

<p>Most of the plain text file formats fall into one of the following two categories: <strong>Delimited</strong> and <strong>Fixed Width</strong></p>

<ul>
  <li>Delimitted files are organized such that columns and rows are seperated by a certain character called a delimiter</li>
  <li>Fixed width files are those where each entry in a column has a fixed number of characters</li>
</ul>

<p>We will focus on the delimited .csv file type. csv is an acronym which stands for ‘<strong>C</strong>omma <strong>S</strong>eparated <strong>V</strong>alues’ and informs us that the column entries are delimited by commas and the rows are delimited by a new line. So, the example we discussed in this cell conforms to the .csv format.</p>

<p>Included in the Pandas toolkit is a <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html">collection</a> of parsing functions to read and build <code class="language-plaintext highlighter-rouge">DataFrames</code> from data that is stored in a variety of formats. The Pandas function which parses and builds a <code class="language-plaintext highlighter-rouge">DataFrame</code> from a generic delimited plain text file is <code class="language-plaintext highlighter-rouge">read_csv()</code>. To run <code class="language-plaintext highlighter-rouge">read_csv()</code> with the default settings we only need to provide 1 positional argument, the path to the file we want to read. If we wanted to read a file in the same directory as our notebook called <code class="language-plaintext highlighter-rouge">p</code> and put the data into a new Pandas <code class="language-plaintext highlighter-rouge">DataFrame</code>, <code class="language-plaintext highlighter-rouge">df</code>, we would type <code class="language-plaintext highlighter-rouge">df = pd.read_csv(p)</code>.</p>

<p>However, parsing plain text files can become a complicated procedure. To aid in the process, Pandas provides a lot of optional parameters that may be set when calling the <code class="language-plaintext highlighter-rouge">read_csv()</code> function. To learn more, see the <code class="language-plaintext highlighter-rouge">read_csv()</code> <a href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html">documentation</a>, which summarizes all of the parameters. We will be covering many of the most important parameters throughout the rest of this lesson.</p>

<p>By default <code class="language-plaintext highlighter-rouge">read_csv()</code> will separate data entries when it encounters a comma and will separate rows by new lines encoded by ‘\n’. If we wanted to change this behavior so that <code class="language-plaintext highlighter-rouge">read_csv()</code> separates by tabs (encoded with \t), then we can set the optional parameter <code class="language-plaintext highlighter-rouge">sep = '\t'</code>. For instance, if we wanted to read the data in the file ‘tsv_example.tsv’, which is a tab separated values file, and save the data in a Pandas <code class="language-plaintext highlighter-rouge">DataFrame</code> called <code class="language-plaintext highlighter-rouge">df</code>, then we would type:</p>

<div class="alert alert-secondary" role="alert">

  <h6 id="python-1">Python</h6>
  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'data/tsv_example.tsv'</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">)</span>
</code></pre></div>  </div>

</div>

<p>Though <code class="language-plaintext highlighter-rouge">read_csv()</code> can handle <code class="language-plaintext highlighter-rouge">.tsv</code> files, there is a specific parsing function for <code class="language-plaintext highlighter-rouge">.tsv</code> files: <code class="language-plaintext highlighter-rouge">read_table()</code>. The difference between <code class="language-plaintext highlighter-rouge">read_table()</code> and <code class="language-plaintext highlighter-rouge">read_csv()</code> is that the default behavior for the latter is to separate using commas instead of tabs <code class="language-plaintext highlighter-rouge">\t</code>. The <code class="language-plaintext highlighter-rouge">read_table()</code> documentation is available at this <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_table.html">link</a>.</p>

<p>To perform the same operation (that is reading the data in the file <code class="language-plaintext highlighter-rouge">tsv_exampletsv</code> and save the data in a Pandas <code class="language-plaintext highlighter-rouge">DataFrame</code> called <code class="language-plaintext highlighter-rouge">df</code>), we may use the <code class="language-plaintext highlighter-rouge">read_table()</code> function without having to define our delimiter, since the default parameters will correctly parse our file.</p>

<div class="alert alert-secondary" role="alert">

  <h6 id="python-2">Python</h6>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_table</span><span class="p">(</span><span class="s">'data/tsv_example.tsv'</span><span class="p">)</span>
</code></pre></div>  </div>

</div>

<p>Both methods will lead to an equivalent <code class="language-plaintext highlighter-rouge">DataFrame</code>.</p>

<figure>
  
    <img src="/morea/data-wrangling/fig/E3_2_loaded_dataframe.png" style="max-width: 60%;" alt="/Loaded%20Dataframe" class="img-fluid mx-auto d-block border" />
  
  <figcaption style="text-align: center">
    <small>
      
    </small>
  </figcaption>
</figure>

<p>In the previous examples we loaded the entire dataset from the file we gave Pandas. However, when working with large datasets it is good practice to load your data in small pieces before loading the entire dataset to ensure that the file is parsed correctly. Small data sets are more manageable and errors are easier to spot, while large data sets take more time to parse. So, a good workflow is to read a small portion of the data and analyze the resulting data frame to see if you need to modify any of the default behaviors of the read function.</p>

<p>To load only up to a limited number of rows we can use the <code class="language-plaintext highlighter-rouge">nrows</code> parameter for both <code class="language-plaintext highlighter-rouge">read_table()</code> and <code class="language-plaintext highlighter-rouge">read_csv()</code>. For example, the file E3_tara_w1.csv is a csv file with over 200 rows, but if we wanted to read only the first 5 rows of this file we can call the Pandas <code class="language-plaintext highlighter-rouge">read_csv()</code> function and set <code class="language-plaintext highlighter-rouge">nrows = 5</code>:</p>

<div class="alert alert-secondary" role="alert">

  <h6 id="python-3">Python</h6>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'data/tsv_example.tsv'</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">df</span><span class="p">.</span><span class="n">shape</span> <span class="c1"># Returns the number of rows and columns of the DataFrame 'df' (rows, columns)
</span></code></pre></div>  </div>

  <h6 id="output">Output</h6>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(5, 7)
</code></pre></div>  </div>

</div>

<p>We see that the <code class="language-plaintext highlighter-rouge">DataFrame</code> <code class="language-plaintext highlighter-rouge">df</code>, that we saved the data in, has a shape attribute of <code class="language-plaintext highlighter-rouge">(5, 7)</code>. This means that there are 5 rows (since we set <code class="language-plaintext highlighter-rouge">nrows=5</code>) and 7 columns (all the columns of the dataset).</p>

<h2 id="headers-and-indexes">Headers and Indexes</h2>

<div class="alert alert-secondary" role="alert">

  <p>When we loaded the previous datasets <code class="language-plaintext highlighter-rouge">read_csv()</code> assumed that the first row in our .csv file contained headers for each of the columns. If we want to load in a dataset that does not contain a header row we can tell <code class="language-plaintext highlighter-rouge">read_csv()</code> that there is no header by setting <code class="language-plaintext highlighter-rouge">header=None</code>.</p>

  <h6 id="python-4">Python</h6>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">"data/noheader_example.csv"</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="n">df</span>
</code></pre></div>  </div>
</div>

<p>However, this does not mean that the <code class="language-plaintext highlighter-rouge">DataFrame</code> does not have headers but rather that Pandas will set them to be an integer value. An example is shown in the figure below:</p>

<figure>
  
    <img src="/morea/data-wrangling/fig/E3_3_no_columns_dataframe.png" style="max-width: 60%;" alt="/No%20Headers%20Dataframe" class="img-fluid mx-auto d-block border" />
  
  <figcaption style="text-align: center">
    <small>
      
    </small>
  </figcaption>
</figure>

<p>You might also notice that there is also a corresponding integer number in the far left side of each row. This is the index that is essentially the “name” for each row. If we have a column that is specifies each row in the Python file we can tell Pandas to use that column instead of the default of using a integer. This can be done by e.g. setting <code class="language-plaintext highlighter-rouge">index_col='unique_id'</code> however, if you don’t have any headers you can also specify the column by using its integer location e.g. <code class="language-plaintext highlighter-rouge">index_col=0</code>. <strong>Note that the integer location of a column goes from left to right and starts at 0.</strong></p>

<div class="alert alert-secondary" role="alert">
  <h6 id="python-5">Python</h6>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'data/noheader_example.csv'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">df</span>
</code></pre></div>  </div>
</div>

<figure>
  
    <img src="/morea/data-wrangling/fig/E3_4_no_column_index_specified_dataframe.png" style="max-width: 60%;" alt="/No%20Headers%20Index%20Specified%20Dataframe" class="img-fluid mx-auto d-block border" />
  
  <figcaption style="text-align: center">
    <small>
      
    </small>
  </figcaption>
</figure>

<p>You can change the name of the index column by setting the index name attribute of the dataframe <code class="language-plaintext highlighter-rouge">df.index.name = 'unique_id'</code>.</p>

<h2 id="common-data-loading-problems">Common Data Loading Problems</h2>

<p>Though data storage in plain text files should follow certain formats like .csv for ‘<strong>C</strong>omma <strong>S</strong>eparated <strong>V</strong>alues’ and .tsv for ‘<strong>T</strong>ab <strong>S</strong>eparated <strong>V</strong>alues’, there is still some ambiguity on how things like missing entries, and comments should be denoted. For this reason Pandas has implemented functionality into the <code class="language-plaintext highlighter-rouge">read_table()</code> and <code class="language-plaintext highlighter-rouge">read_csv()</code> to help ‘clean’ plain text data.</p>

<p>Below we will go through two examples of common issues when loading in data.</p>

<h3 id="missing-values">Missing Values</h3>

<p>There are often missing values in a real-world data set. These missing entries may be identifiable in the dataset by a number of different tags, like ‘NA’, ‘N.A.’, ‘na’, ‘missing’, etc. It is important to properly identify missing values when creating a <code class="language-plaintext highlighter-rouge">DataFrame</code> since certain <code class="language-plaintext highlighter-rouge">DataFrame</code> methods rely on the missing values being accounted for. For example, the <code class="language-plaintext highlighter-rouge">count()</code> method of a <code class="language-plaintext highlighter-rouge">DataFrame</code> returns the number of non missing values in each column. If we want this to be an accurate count, then we need to be sure of pointing out all the tags which represent ‘missing’ to Pandas.</p>

<p>For example, if we were to load in a .csv where missing values are ‘Null’ and not specify this then Pandas will load these values in as objects. To let Pandas know that we want to interpret these values as missing values we can add <code class="language-plaintext highlighter-rouge">na_values='Null'</code>.</p>

<div class="alert alert-secondary" role="alert">

  <h6 id="python-6">Python</h6>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">"data/null_values_example.csv"</span><span class="p">,</span> <span class="n">na_values</span><span class="o">=</span><span class="s">'Null'</span><span class="p">)</span>
<span class="n">df</span>
</code></pre></div>  </div>
</div>

<p><strong>Without <code class="language-plaintext highlighter-rouge">na_values='Null'</code>:</strong></p>

<figure>
  
    <img src="/morea/data-wrangling/fig/E3_5_null_values.png" style="max-width: 60%;" alt="/Null%20values%20Dataframe" class="img-fluid mx-auto d-block border" />
  
  <figcaption style="text-align: center">
    <small>
      
    </small>
  </figcaption>
</figure>

<p><strong>With <code class="language-plaintext highlighter-rouge">na_values='Null'</code>:</strong></p>

<figure>
  
    <img src="/morea/data-wrangling/fig/E3_6_nan_values.png" style="max-width: 60%;" alt="/NaN%20values%20Dataframe" class="img-fluid mx-auto d-block border" />
  
  <figcaption style="text-align: center">
    <small>
      
    </small>
  </figcaption>
</figure>

<h2 id="auto-nan-values">Auto NaN values</h2>

<p>Pandas will interpret certain values as being NaN values even without user Python. For example if ‘NULL’ is found then Pandas will treat it as a missing value and treat it as a NaN value.</p>

<h2 id="writing-data-in-text-format">Writing Data in Text Format</h2>

<p>Now that we are familiar with the reading mechanisms that Pandas has implemented for us, writing <code class="language-plaintext highlighter-rouge">DataFrames</code> to text files follows naturally. Pandas <code class="language-plaintext highlighter-rouge">DataFrames</code> have a collection of <code class="language-plaintext highlighter-rouge">to_&lt;filetype&gt;</code> methods we can call; we will focus on <code class="language-plaintext highlighter-rouge">to_csv()</code>. <code class="language-plaintext highlighter-rouge">to_csv()</code> takes the parameter path (the name and location of the file you are writing) and will either create a new file or overwrite the existing file with the same name.</p>

<p><code class="language-plaintext highlighter-rouge">to_csv()</code> has a number of optional parameters that you may find useful, all of which can be found in the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html">Pandas documentation</a>.</p>

<div class="alert alert-secondary" role="alert">

  <h6 id="python-7">Python</h6>

  <pre><code class="language-Python">df.to_csv('data/new_file.csv')
</code></pre>

</div>

<h2 id="key-points">Key Points</h2>

<div class="alert alert-success" role="alert">

  <ul>
    <li>“Pandas provides numerous attributes and methods that are useful for wrangling and analyzing data”</li>
    <li>“Pandas contains numerous methods to help load/write data to/from files of different types”</li>
  </ul>
</div>

<div class="alert alert-secondary" role="alert">
  <p><i class="fa-solid fa-user-pen fa-xl"></i>  <strong>Exercise: Loading An Excel File</strong></p>
  <hr />

  <p>Try it yourself! Load the first 10 lines of the excel file ‘20_sales_records.xlsx’ into a variable and then display your DataFrame. Identify the number of rows and columns of your resulting DataFrame.</p>

  <ul>
    <li>The file is located in the <code class="language-plaintext highlighter-rouge">data</code> folder.</li>
    <li>Use the <code class="language-plaintext highlighter-rouge">read_excel</code> command along with the argument you learned to parse a specified number of rows.</li>
    <li>This file has <code class="language-plaintext highlighter-rouge">NaN</code> values that are not automatically detected. They are labeled as <code class="language-plaintext highlighter-rouge">'none'</code>. Have Pandas interpret these as <code class="language-plaintext highlighter-rouge">NaN</code> values upon loading of the dataset.</li>
    <li>Display the results.</li>
    <li>Identify the number of rows and columns of your resulting DataFrame.</li>
  </ul>

  <details>
  <summary>Solution</summary>

  '20_sales_records.xlsx' is an excel file containing 20 rows of data, but we only want Pandas to parse the first 10 rows. In addition, we want to interpret exisitng 'none' values as `NaN` values. This can all be accomplished with the following line of code:
  
  <pre>
    sales_df = pd.read_excel('data/20_sales_records.xlsx', nrows=10, na_values='none')  
  </pre>

Below shows how our `DataFrame` now looks:
<figure>
  
    <img src="/morea/data-wrangling/fig/E3_7_exercise.png" style="max-width: 40%;" alt="/Output%20DataFrame" class="img-fluid mx-auto d-block border" />
  
  <figcaption style="text-align: center">
    <small>
      
    </small>
  </figcaption>
</figure>


The resulting `DataFrame` should have 10 rows, 14 columns, and `NaN` values replacing the 'none' values.
</details>
</div>

<div style="text-align: right; padding-bottom: 10px">
  <hr />
  <button type="button" onclick="window.location='/morea/data-wrangling/experience-dataframe-wrangling.html'" class="btn btn-primary">
    <p style="font-size:16px; margin: 0">Dataframe Wrangling -&gt;</p>
    <p style="font-size:12px; margin: 0">2:40pm</p>
    </button>
</div>


</div>




<!-- Maybe find a different way?
<script src="/js/scrollIfAnchor.js"></script>
-->

<footer class="footer footer-background" style="padding-top: 1em; padding-bottom: 1em">
  <div class="container text-center">
    
    

    
    <p style="margin: 0">Powered by the <a class="footer-link" href="https://morea-framework.github.io/">Morea Framework</a> (Theme: spacelab)<br>
      Last update on: <span>2023-10-05 19:51:18 -1000</span></p>

    <p style="margin: 0">
      
      18 modules
      
      | 17 outcomes
      
      
      | 53 readings
      
      
      | 92 experiences
      
      
      | 13 assessments
      
    </p>
  </div>
</footer>


<!-- Load Bootstrap JavaScript components -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>


<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
</script>


<!-- Add anchors to pages. -->
<script>anchors.add();</script>


</body>
</html>
